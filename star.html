<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bigger Ripple Reflective Scene</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#120030');

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 3, 12); 

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  // 星空
  const stars = new THREE.BufferGeometry();
  const starVerts = [];
  for (let i = 0; i < 300; i++) {
    starVerts.push((Math.random() - 0.5) * 200, Math.random() * 80, (Math.random() - 0.5) * 200);
  }
  stars.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
  const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6 });
  scene.add(new THREE.Points(stars, starMat));

  // 更亮的水面
  const water = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshStandardMaterial({
      color: 0x4477aa,
      metalness: 0.6,
      roughness: 0.15,
      envMapIntensity: 1.0,
      transparent: true,
      opacity: 0.95
    })
  );
  water.rotation.x = -Math.PI / 2;
  scene.add(water);

  // 光源
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
  directionalLight.position.set(5, 15, 10);
  scene.add(directionalLight);
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));

  // 中央點光源打亮平台/水面
  const glowLight = new THREE.PointLight(0x88ccff, 2.5, 20);
  glowLight.position.set(0, 2, 0);
  scene.add(glowLight);

  // CubeCamera for reflections
  const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, {
    format: THREE.RGBAFormat,
    generateMipmaps: true,
    minFilter: THREE.LinearMipmapLinearFilter
  });
  const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
  scene.add(cubeCamera);

  // 平台
  const hex = new THREE.Mesh(
    new THREE.CylinderGeometry(4, 4, 0.5, 6),
    new THREE.MeshStandardMaterial({ color: '#a399ff', metalness: 0.6, roughness: 0.3 })
  );
  hex.rotation.y = Math.PI / 6;
  hex.position.y = 0.25;
  scene.add(hex);

  // 反射球體
  const reflectiveSphere = new THREE.Mesh(
    new THREE.SphereGeometry(1.4, 64, 64),
    new THREE.MeshStandardMaterial({ 
      envMap: cubeRenderTarget.texture, 
      metalness: 1, 
      roughness: 0, 
      envMapIntensity: 2 
    })
  );
  reflectiveSphere.position.set(2.3, 2, 0);
  scene.add(reflectiveSphere);

  // 發光立方體
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(1.3, 1.3, 1.3),
    new THREE.MeshStandardMaterial({ color: '#5533ff', emissive: '#2200ff', emissiveIntensity: 0.2 })
  );
  cube.position.set(-2.3, 1.6, 0);
  scene.add(cube);

  // 玻璃柱
  const glassBox = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 2.5, 0.4),
    new THREE.MeshStandardMaterial({
      color: 0x88bbff,
      metalness: 0.5,
      roughness: 0.05,
      transparent: true,
      opacity: 0.5
    })
  );
  glassBox.position.set(0, 2.1, -0.4);
  glassBox.rotation.z = Math.PI / 4;
  scene.add(glassBox);

  // 球形罩
  const bigDome = new THREE.Mesh(
    new THREE.SphereGeometry(5.5, 64, 64),
    new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0.5,
      roughness: 0.05,
      transmission: 1.0,
      thickness: 1.0,
      envMap: cubeRenderTarget.texture,
      transparent: true,
      opacity: 0.4
    })
  );
  bigDome.position.set(0, 2.4, 0);
  scene.add(bigDome);

  // 更大的波紋
  const rippleMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const rippleGeometry = new THREE.RingGeometry(0.6, 0.75, 64);  // 原本是 0.1 - 0.12
  const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
  ripple.rotation.x = -Math.PI / 2;
  ripple.position.set(2.3, 0.02, 0);
  scene.add(ripple);

  // 動畫
  const clock = new THREE.Clock();
  let rippleScale = 0.1;
  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    cube.rotation.y += 0.01;
    glassBox.rotation.y += 0.002;
    reflectiveSphere.rotation.y += 0.01;
    reflectiveSphere.position.y = 2 + Math.sin(t * 2) * 0.3;
    bigDome.rotation.y += 0.002;

    // 波紋動畫
    rippleScale += 0.03;
    ripple.scale.set(rippleScale, rippleScale, rippleScale);
    ripple.material.opacity = Math.max(0, 0.5 - rippleScale * 0.1);
    if (rippleScale > 5.0) rippleScale = 0.1;

    // 反射更新
    reflectiveSphere.visible = false;
    cubeCamera.update(renderer, scene);
    reflectiveSphere.visible = true;

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>



